"""
Generates a graph from the imdb data.

Default is only actors, and only movies.
"""

from django.db.models import Q
from .models import Title, Name, Principal
from collections import deque

KEVIN_BACON = Name.objects.filter(
    Q(primary_name='Kevin Bacon') &
    Q(birth_year=1958)
)
KEVIN_BACON_ID = 'nm0000102'


def generate_graph():
    """
    Generate a graph represented as a dictionary.

    Actors as keys, vals are their neighbors (other actors).

    Parallel edges are stored as a dict within a dict:
    actors (neighbor nodes) are the keys, the movies(s) in
    common (edges) are the values.
    """
    # actors = Name.objects.filter(
    #     Q(professions__icontains='actor') |
    #     Q(professions__icontains='actress')
    # )

    movies = Title.objects.filter(title_type='movie')

    graph = {}

    # iterate through movies, find actors for each and create nodes
    for movie in movies:
        actors = Principal.objects.filter(title_id=movie.id)
        costars = set(actors)

        for actor in actors:
            # remove current actor from costars
            costars.remove(actor)

            # if actor not in graph, add actor and its neighbors
            # with current movie as edge
            if actor not in graph:
                graph[actor] = {costars: set(movie) for costar in costars}
            else:
                # check if costars are already neighbor nodes before adding
                for costar in costars:
                    if costar not in graph[actor]:
                        graph[actor][costar] = set(movie)
                    else:
                        graph[actor][costar].add(movie)

            # add current actor back to costars
            costars.add(actor)

    return graph
    # iterate through actors, find costars for each movie
    # for actor in actors:
    #     # add actor node to dict
    #     graph[actor] = {}
    #     actors_movies = Principal.objects.filter(name_id=actor.id)
    #
    #     for movie in actors_movies:
    #         costars = Principal.objects.filter(
    #             Q(title_id=movie.id) &
    #             ~Q(name_id=actor.id)
    #         )
    #
    #         for costar in costars:
    #             # check if costar already in graph
    #             if costar in graph[actor]:
    #                 graph[actor][costar].add(movie)
    #             else:
    #                 graph[actor][costar] = set([movie])


def bfs(graph, end, start=KEVIN_BACON_ID):
    """
    Perform BFS on given graph from start to end nodes.

    Start and end are given as name_ids.
    If there are multiple paths, returns one of them (??)
    """
    # initialize queue
    queue = deque()
    prev_node = {}  # keeps track of where you come from (recreate path)

    queue.append(start)

    while len(queue) > 0:
        current = queue.popleft()

        neighbors = graph[current]

        for neighbor in neighbors:
            # if neighbor hasn't been visited, add to queue
            # and mark the node you visit it from
            if neighbor not in prev_node:
                queue.append(neighbor)
                prev_node[neighbor] = (current, graph[current][neighbor])


def get_path(prev_nodes, start, end, reverse=False):
    """
    Return path from start to end node using prev_nodes generated by bfs.

    Reverse allows returning path in reverse in case Kevin Bacon (default)
    is changed to be end node. Allows for optimization by not rerunning graph.

    Returns a list of tuples of form (actor, movie(s))
    """
    prev = prev_nodes[end]
    actor = prev[0]
    movies = prev[1]
    path = deque()

    # refactor to optimize with append/appendleft instead of reversing
    while actor != start:
        path.appendleft((actor, movies))
        prev = prev_nodes[actor]
        actor = prev[0]
        movies = prev[1]

    if reverse:
        path.reverse()

    return path
